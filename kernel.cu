???
#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#define BLOCK_DIM 256
#include <stdio.h>
#include <math.h>
#include <locale.h>
#include <stdio.h>
#include <conio.h>
#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <omp.h>
#include <cuda_runtime_api.h>



struct pairU 
{
	int col;
	int row;
	pairU(int c, int r)
	{
		col = c;
		row = r;
	}
	__device__ pairU() {}
};


__global__ void rotateKernel(double *a, int n, int j)
{
	
	pairU p;
	int i = threadIdx.x;
	int t = blockIdx.y;
	int firstIndex, secondIndex;
	double thirdIndex, fouthIndex;
	double tempOne, tempTwo;
	double r,c,s;
	int numThreads = 0;
	__shared__ double tempArr1[256];
	__shared__ double tempArr2[256];
	__shared__ double tempArr3[256];



	for(int e = 0; e < j; e++)
	{
	
		r = rsqrt(tempArr1[e]*tempArr1[e]+tempArr2[e]*tempArr2[e]);
		c  = tempArr2[e] * r;
		s = -tempArr1[e] * r;

		for(int h = 0; h < (n / BLOCK_DIM + 1); h++)
		{
			if( i < (n - h*BLOCK_DIM))
			{
				tempOne = tempArr2[i]; tempTwo = tempArr1[i];
				tempArr2[i] = c * tempOne - s * tempTwo;
				tempArr1[i] = c * tempTwo + s * tempOne;

	
				__syncthreads();
				if(e <= (j - 2))
				{
					r = rsqrt(tempArr2[e]*tempArr2[e]+tempArr3[e]*tempArr3[e]);
					c  = tempArr3[e] * r;
					s = -tempArr2[e] * r;
					tempOne = tempArr3[i]; tempTwo = tempArr2[i];
					tempArr3[i] = c * tempOne - s * tempTwo;
					tempArr2[i] = c * tempTwo + s * tempOne;	
				}
				__syncthreads();
			}
		}
	}

	a[j*n + i] = tempArr1[i];
	a[(j-1)*n + i] = tempArr2[i];
	a[(j-2)*n + i] = tempArr3[i];

	//nextRotate(p,n,2,c,s,a);

}




int main()
{
	setlocale( LC_ALL, "Russian" );
	double *a;	//???????????? ??????????????????????????


	int n;			//???????????????????? ?????????????????????? ??????????????




	printf("??????????????? ???????????????? ???????????????? ????????????????\n");
	printf("-------------------------------------------\n");
	printf("?????????? ???????????????\n");

	//???????? ?????????????????????? ?????????????? ??????????????????
	printf("?????????????? ?????????????????????? ?????????????? ??????????????????=");
	scanf("%d",&n);
	
	a = new double[n*n];

	//???????? ???????????????? ?????????????? ????????????????????????
#pragma omp parallel for
	for(int i=0;i<n;i++)			
	{
		for(int j=0;j<n;j++)
		{
			
			a[i*n + j] = (double)rand()/(double)100;
			
		}
		
	}

	double *dev_a = 0;

    cudaError_t cudaStatus;

    // Choose which GPU to run on, change this on a multi-GPU system.
    cudaStatus = cudaSetDevice(0);
    cudaStatus = cudaMalloc((void**)&dev_a, n * n * sizeof(double));

    cudaStatus = cudaMemcpy(dev_a, a, n * n * sizeof(double), cudaMemcpyHostToDevice);

	int numStages = n * 2 - 3;

	cudaDeviceProp p;
	cudaGetDeviceProperties(&p,0);
	dim3 gridSize;
	dim3 blockSize;
	gridSize = dim3(1, n-1, 1);
	if(n > BLOCK_DIM)
		blockSize = dim3(BLOCK_DIM, 1, 1);
	else
		blockSize = dim3(n, 1, 1);    //???????????? ?????????????????????????? ??????????
	
	gridSize = dim3(1, 1, 1);
 //???????????? ?????????????????????????? ??????????

	
	//???????????? ??????
	
	 
	 //printf("%f",summ);
	
	double t1 = omp_get_wtime();
	cudaError_t vb;
	int numThreads = 0;

	for (int j=n-1; j >= 2;j -= 2)
	{
		rotateKernel<<<gridSize, blockSize>>>(dev_a, n, j);
	}
	
	

	
	cudaStatus = cudaMemcpy(a, dev_a, n * n * sizeof(double), cudaMemcpyDeviceToHost);
	double t2 = omp_get_wtime();
	cudaFree(dev_a);
	for(int q = 0; q < n; q++)
	{
		//for(int r = 0; r < n; r++)
		printf("%f ", a[(n-1)*n + q]);
		//printf("\n");
	}
	printf("\n\n%f\n\n",t2 - t1);
	getch();




    // cudaDeviceReset must be called before exiting in order for profiling and
    // tracing tools such as Nsight and Visual Profiler to show complete traces.
    cudaStatus = cudaDeviceReset();
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaDeviceReset failed!");
        return 1;
    }

    return 0;
}
????????????? ??????????
	
	gridSize = dim3(1, 1, 1);
 //???????????? ?????????????????????????? ??????????

	
	//???????????? ??????
	
	 
	 //printf("%f",summ);
	
	double t1 = omp_get_wtime();
	cudaError_t vb;
	int numThreads = 0;

	for (int j=n-1; j >= 2;j -= 2)
	{
		rotateKernel<<<gridSize, blockSize>>>(dev_a, n, j);
	}
	
	

	
	cudaStatus = cudaMemcpy(a, dev_a, n * n * sizeof(double), cudaMemcpyDeviceToHost);
	double t2 = omp_get_wtime();
	cudaFree(dev_a);
	for(int q = 0; q < n; q++)
	{
		//for(int r = 0; r < n; r++)
		printf("%f ", a[(n-1)*n + q]);
		//printf("\n");
	}
	printf("\n\n%f\n\n",t2 - t1);
	getch();




    // cudaDeviceReset must be called before exiting in order for profiling and
    // tracing tools such as Nsight and Visual Profiler to show complete traces.
    cudaStatus = cudaDeviceReset();
    if (cudaStatus != cudaSuccess) {
        fprintf(s